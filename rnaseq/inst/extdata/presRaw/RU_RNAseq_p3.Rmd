---
title: "Analysis of RNAseq data in R and Bioconductor (part 3)<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
date: "http://rockefelleruniversity.github.io/RU_RNAseq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```


```{r setup, include=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(GenomicAlignments)
library(DESeq2)
library(tximport)
library(org.Mm.eg.db)
library(goseq)
```

## The data

In this session we will be reviewing the same data that we used in the first two sessions. This is the data from Christina Leslie's lab at MSKCC on T-Reg cells and activated T-Reg cells. T-Reg data can be found on the Encode portal [here](https://www.encodeproject.org/experiments/ENCSR486LMB/) and activated T-Reg data [here](https://www.encodeproject.org/experiments/ENCSR726DNP/)

I have aligned all FQ to BAM and counted in genes and exons using Rsubread and summariseOverlaps() and then analysed this data for expression changes using DESeq2.

---
## The data

All Gene and Exon counts can be found as .RData obects in **data** directory

- Counts in genes can be found at - **data/GeneCounts.RData**
- Counts in disjoint exons can be found at - **data/ExonCounts.RData**

- Salmon transcript quantification output directories can be found under - **data/Salmon/**

---
## The data

You can find an excel file of differential expression analysis for this comparison in the **data** directory.

- CSV file of differential expression results for activated versus resting T-cells - **data/Group_Activated_minus_Resting.csv**.


---
## What we will cover

In our last session we will looked at how we can identify changes in gene expression from two separate methods to gene expression estimates and looked a little at the output from comparing differential expression levels using DESeq2.

In this session we will explore a few ways we can evaluate any enrichment for functionally related genes from our differential expression analysis. This helps us address common questions like:

**Are genes related to "immune response" enriched in my set of significantly upregulated genes?**

**Do "cell cycle" genes change more between conditions then other genes?**


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Gene Sets

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Gene Sets

---
"    
  )
  
}

```

## What we test and how we test?

There are many options available to us for both functions/pathways/categories **(Gene set)** we will test and the methods we can use to test these gene sets for enrichment in our analysis **(Gene set Enrichment Analysis)**.

- **Gene set** - A named collection of genes.
- **Gene Set enrichment Analysis - GSA** - Broad term for correlating a set of genes with a condition/phenotype.
- **Gene Set Enrichment Analysis - GSEA** - Broad Institute's term for correlating a set of genes with a condition/phenotype.


---
## Gene set testing

A frequent step in RNAseq analysis is to test whether any functionally related sets of genes are enriched within our differential expressed genes.

Sources of well curated gene sets include [GO consortium](http://geneontology.org/) (gene's function, biological process and cellular localization), [REACTOME](http://www.reactome.org/) (Biological Pathways) and [MsigDB](http://software.broadinstitute.org/gsea/msigdb/) (Computationally and Experimentally derived).

---
## Gene Ontology

The [Gene Ontology consortium](http://geneontology.org/) aims to provide a comprehensive resource of all the currently available knowledge regarding the functions of genes and gene products.

Functional categories of genes are broadly split into three main groups:

* **Molecular functions.** - Activity of a gene's protein product.
* **Biological processes.** - Role of gene's protein product.
* **Cellular components.** - Where in cell molecular function of protein product is performed.

---
## Gene Ontology

The three sub categories of gene ontology are arranged in nested, structured graph with gene sets at the top of graph representing more general terms and those at the bottom more specific terms.

![](imgs/goGraph.png)


---
## Reactome and KEGG

The [Reactome](http://www.reactome.org/) and [KEGG (Kyoto Encyclopedia of genes and genomes)](http://www.genome.jp/kegg/kegg2.html) contains information on genes' membership and roles in  molecular pathways.

These databases focus largely on metabolic and disease pathways, and allow us to investigate our genes in the context of not only functional roles but relative positions within pathways.


<div align="center">
<img src="imgs/map01100.png" alt="offset" height="300" width="600">
</div>


---
## MsigDB
.pull-left[
The [molecular signatures database (MsigDB)](http://software.broadinstitute.org/gsea/msigdb/) is available from the Broad institute and provides a set of curated gene sets derived from sources such as GO, pathway databases, motif scans and even other experimental sets.

MsigDB databases are widely used in Gene Set Enrichment Analysis and are available as plain text, in formats used with the popular Java based gene set enrichment software GSEA.
]
.pull-right[
<div align="center">
<img src="imgs/msigdb.png" alt="offset" height="500" width="350">
</div>
]


---
## Gene sets in Bioconductor

In R we can access information on these gene sets through database libraries (such as the Org.db.eg we have reviewed) such as **GO.db**, **KEGG.db**, **reactome.db** or by making use of libraries which allows us to our gene sets from parse plain text formats, **GSEABase**.

In our [Bioconductor sessions](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/singlepage/GenomicFeatures_In_Bioconductor.html#Gene_Annotation) we reviewed how we to get information on genes using the **Org.db** packages. We can access these dbs in similar ways. 

```{r,eval=T,echo=T, eval=F, echo=T, warning=FALSE,tidy=T}
library(GO.db)
library(KEGG.db)
library(reactome.db)
library(GSEABase)

```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# MSigDB and Gene Set Collections

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# MSigDB and gmt files

---
"    
  )
  
}
```

## GSEA and MSigDB

The GSEA software and MSigDB gene set collections can be found at the [Broad's site](http://software.broadinstitute.org/gsea/index.jsp).

We have access to Human gene sets containing information on:

* H	- hallmark gene sets
* C1	- positional gene sets
* C2	- curated gene sets
* C3	- motif gene sets
* C4	- computational gene sets
* C5	- GO gene sets
* C6	- oncogenic gene sets 
* C7	- immunologic gene sets

---
## MSigDB and gmt format

The **gmt** (gene matrix transposed) is a GSEA specific format which is easy to edit in spreadsheet programs.

It contains tab separated space with lines containing gene sets of differing sizes.

---
## GSEAbase

We can read gene sets stored in the gmt format into R using the GSEABase package.

```{r ,gseabase, warning=F, message=F}
library(GSEABase)
```

---
## Reading gmt

The GSEABase function **getGmt** allows us to import our gmt formatted gene set collection into a **GeneSetCollection** object. In this case we are reading in the Hallmarks gene set with gene symbols which we downloaded from the [Broad website.](http://software.broadinstitute.org/gsea/index.jsp)

```{r, Readinggmt, eval=TRUE, echo=T}
hallMarks <- getGmt(con="data/h.all.v7.1.symbols.gmt")
hallMarks
```


---
## GeneSetCollection

The GeneSetCollection object can be subset as a list.

```{r, GeneSetCollection}
hallMarks[1]
hallMarks[[1]]
```

---
## GeneSetCollection

We can access the names of gene sets using the **names()** accessor

```{r, names}
names(hallMarks)
```

---
## GeneSetCollection

The geneIDs() function returns a list named by gene set with each named element containing the genes (their IDS) contained within that set.

```{r, geneIDs}
geneIds(hallMarks)[1:3]
```

---

## Beyond human gene sets

To make use of human gene sets in other species we can either:

- Use an alternative organism specific set.
- Translate relevant set to mouse ortholog names.

---
## gskb 

The **gskb** package holds many pathways and gene sets for mouse genome equivalent to MSigDB.

First we can load the package.
*THIS IS DEPRECATED IN THE MOST RECENT VERSIONS OF R*
```{r, gskb, eval =F}
library(gskb)
```

---

## gskb datasets

The **gskb** package contains 7 collections of genes.

* mm_GO - gene sets from Gene Ontology for mouse (*Mus musculus*).
* mm_location - Gene sets based on chromosomal location.
* mm_metabolic - metabolic pathways.
* mm_miRNA - Target genes of microRNAs, predicted or experimentally verified.
* mm_pathway - Curated pathways.
* mm_TF - Transcription factor target genes.
* mm_other - Everything else.

---

## Accessing gskb data

We access gskb datasets by using the **data()** function to load into memory the gene set collection of interest.
*THIS IS DEPRECATED IN THE MOST RECENT VERSIONS OF R*
```{r, data, eval=F}
data(mm_miRNA)
names(mm_miRNA)[1:2]
mm_miRNA[1]
```

---
## Msigdbr

An alternative is that we translate our human MSigDB collection to other organisms. Thankfully someone already did just this for us, for a number of common species. This is all wrapped up in the [*msigdbr* CRAN package](https://igordot.github.io/msigdbr/).

The msigdbr function is used to specify which organism and which categories you want. In return you get a simple dataframe. 


```{r, wehiA }
library(msigdbr)

mm_H <- msigdbr(species = "Mus musculus", category = "H")
head(mm_H)
```


---
## List to GeneSetCollection

We can convert the list to a GeneSetCollection to take advantage of GSEABase functionality.

We must first create a list of **GeneSet** objects using **GeneSet()** constructor and then create **GeneSetCollection** from list usin **GeneSetCollection** constructor.

```{r, wehi3}
myGeneSetList <- list()
gsets<-unique(mm_H$gs_name)

for(i in 1:length(gsets)){
  genes_in_set <- as.character(mm_H$entrez_gene[which(mm_H$gs_name==gsets[i])])
  myGeneSetList[[i]] <- GeneSet(unique(genes_in_set), 
setName=gsets[i])
}

myGeneSetCollection <- GeneSetCollection(myGeneSetList)
myGeneSetCollection
```

---

## GeneSetCollection to gmt

We can now use the toGmt function to export our GeneSetCollection to gmt formated file for use in other software.

```{r, wehi4}
toGmt(myGeneSetCollection,
      con="mouse_Hallmarks.gmt")
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Testing gene set enrichment

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Testing gene set enrichment

---
"    
  )
  
}
```


## Testing gene sets

We will review two different methods to identify functional groups associated with our condition of interest.

* The first method will test for any association of our gene set with our a group of interesting genes (differentially expressed genes) - functional enrichment.
* The second method will test for any association of our gene set with the ranking of all our genes (ranked by measure of differential expression) - GSEA.

---

## DE results from DESeq2

First lets read in our differential expression results from DESeq2 analysis of activated vs resting T-cells.

```{r, deres}
Activated_minus_Resting <- read.delim(file="data/Group_Activated_minus_Resting.csv",sep=",")
Activated_minus_Resting[1:3,]
```

---

## Background

All GSA methods will require us to filter to genes to those tested for differential expression. 

We will therefore filter to all genes which pass our independent filtering step from DESeq2. These will be our genes with no NA in the DESeq2 padj column.

```{r, deresFilter}
Activated_minus_Resting <- Activated_minus_Resting[!is.na(Activated_minus_Resting$padj),]
Activated_minus_Resting[1:3,]

```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Functional enrichment

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Functional enrichment

---
"    
  )
  
}
```

## goseq package

We can use the goseq package to identify any functional enrichment in a set of interesting genes (i.e. differentially expressed). The goseq package requires a named vector of 1s or 0s indicating whether a gene is upregulated/downregulated. 

Here we define a set of genes significantly upregulated in Activated vs Naive T-reg cells (padj <0 05 and log2FC > 0).

```{r func,eval=TRUE,echo=TRUE,cache=TRUE,dependson="anno2"}
UpInAct <- Activated_minus_Resting$padj < 0.05 & 
             Activated_minus_Resting$log2FoldChange > 0
UpInAct <- as.integer(UpInAct)
names(UpInAct) <- Activated_minus_Resting$ENTREZID
UpInAct[1:4]
table(UpInAct)
```



---

## Gene ontology and functional testing
We can see which genomes are supported using the **supportedGenomes()** function.

```{r,include=FALSE}
library(goseq)
```

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
supGenomes <- supportedGenomes()
supGenomes[1:2,]

```

---
## Gene length bias

The **goseq** package is specifically designed to account for potential length biases in differential expression analysis and so can remove any artefactual enrichment for long and short genes.

The **nullp** function assess any biases by evaluating the relationship between differential expression and length. 

```{r func1,eval=TRUE,echo=TRUE,cache=TRUE,dependson="func", warning=F, message=F, fig.height=3.75,fig.width=3.75}
library(goseq)
pwf = nullp(UpInAct, "mm10", "knownGene", plot.fit = TRUE)
```

<div align="center">
<img src="imgs/fir.png" alt="igv" height="200" width="500">
</div>

---
## Functional Enrichment analysis

Having corrected for any bias we can now use the **goseq** function to for enrichment of GO or KEGG terms.

We must specify the genome build and ID we are using (here matching our TxDb.UCSC.**mm10**.**knownGene**.db) and the categories we wish to test (GO:BP, GO:MF, GO:CC, KEGG). 

Here we identify the top enriched functional terms in GO biological processes.
```{r funca,eval=TRUE,echo=FALSE,cache=TRUE,include=FALSE}
load(file = "data/fit.RData")
```

```{r func2,eval=TRUE,echo=TRUE,cache=TRUE,dependson="func1",warning=FALSE,message=FALSE}
GO_UpInAct <- goseq(pwf,"mm10","knownGene",
                       test.cats=c("GO:BP"))
GO_UpInAct[1:3,]
```

---
## Retrieving function groups

We can retrieve the genes in the **immune response (GO:0006955)** functional group using the **select** and the **org.Mm.eg.db** object.



```{r func3,eval=TRUE,echo=TRUE,cache=TRUE,dependson="funca",warning=FALSE,message=FALSE}
library(org.Mm.eg.db)
ImmuneResponseGenes <- AnnotationDbi::select(org.Mm.eg.db,keytype = "GOALL",
                              keys = "GO:0006955",columns = "ENTREZID")
ImmuneResponseGenes

```

---
## Retrieving function groups

We can then filter our DE table, with this GO set of immune response GENES and write to file.


```{r func4,eval=TRUE,echo=TRUE,cache=TRUE,dependson="func3",warning=FALSE,message=FALSE}
IRG_Entrez <- unique(ImmuneResponseGenes$ENTREZID)
IRG_Res <-  Activated_minus_Resting[Activated_minus_Resting$ENTREZID %in% IRG_Entrez,]
write.table(IRG_Res,
            file="data/ImmuneResponseGeneTable.csv",sep=",",
            row.names = FALSE)
IRG_Res[1:3,]
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# GSEA

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# GSEA

---
"    
  )
  
}
```


## GSEA

Another popular method for differential expression analysis is the Broad's GSEA method.

GSEA tests whether our gene set is correlated with the ranking of genes by our differential expression analysis metric using a modified KS-test.

![](imgs/GSEA.jpg)

---
## GSEA inputs

We have already seen how we can write gene set collections as gmt format files. The gmt format is the standard input format for GSEA gene sets.

We will also need to produce a ranked table of gene ids and write to a **rnk** format file. Here will rank by **stat** column to give sensible measure of differential expression. We could also use **log2FoldChange** column if we have modified log2 fold changes using **lfsShrink()** function.

```{r, myRNK}

forRNK <- data.frame(Activated_minus_Resting$ENTREZID,
                     Activated_minus_Resting$stat)

forRNK[1:3,]
```

---

## rnk file

We can now write our results to a rnk file for use within GSEA.

```{r, myRNKwrite}

write.table(forRNK,
            file="data/Activated_minus_Resting.rnk",
            sep="\t",
            col.names = FALSE,
            row.names = FALSE)
```

---

## fgsea

The **fgsea** package provides access to GSEA method within the R framework.

Once installed we can load library in standard way.

```{r, fgsea}
library(fgsea)
```

---

## fgsea

We can make use of gmt files directly by using the **gmtPathways()** function to read our previous created gmt file of mouse translated gene sets.

```{r, gmtPathways_pub, eval=F, echo=T}
mouse_Hallmarks <- gmtPathways("mouse_Hallmarks.gmt")
class(mouse_Hallmarks)
names(mouse_Hallmarks)
```

```{r, gmtPathways, eval=T, echo=F}
mouse_Hallmarks <- gmtPathways("data/mouse_Hallmarks.gmt")
class(mouse_Hallmarks)
names(mouse_Hallmarks)
```


---
## fgsea

Similar to goseq package we need to provide a vector of our ranking metric named by gene id. We can create this from our **rnk** file.

```{r, rnkForR}
Act_minus_Rest_rnk <- read.delim("data/Activated_minus_Resting.rnk",sep="\t",
                                 h=FALSE,row.names = 1)
Act_minus_Rest_gsea <- Act_minus_Rest_rnk[,1]
names(Act_minus_Rest_gsea) <- rownames(Act_minus_Rest_rnk)
Act_minus_Rest_gsea[1:3]
```

---

## fgsea

The **fgsea()** functions requires our gene sets, named vector of ranking metric, the minimum and maximum sizes of gene sets to be tested (to **minSize** and **maxSize** parameters respectively) and the number of permutations to run (**nperm** parameter).

```{r, fgsefun, warning=F, message=F}

Act_minus_Rest_gseaRes <- fgsea(mouse_Hallmarks, 
                                Act_minus_Rest_gsea, 
                                minSize=15, maxSize=500, nperm=1000)
Act_minus_Rest_gseaRes <- Act_minus_Rest_gseaRes[order(Act_minus_Rest_gseaRes$NES,
                                                       decreasing = T),]
Act_minus_Rest_gseaRes[1:2,]
```

---

## fgsea

We can extract leading edge genes from **leadingEdge** column as a list. These are the genes driving your enrichment. 

```{r, fgsefunews}
Act_minus_Rest_gseaRes$leadingEdge
```

---

## fgsea

We can use these leading edge genes to select genes strongly correlated with our condition and within an enriched gene set.

```{r, fgsefuneds}
INTERFERON_Response_LE <- Act_minus_Rest_gseaRes$leadingEdge[[1]]
IR_LE <- Activated_minus_Resting[Activated_minus_Resting$ENTREZID %in% INTERFERON_Response_LE,]
IR_LE[1:2,]
```


---
## GSEA plots

We can also produce a GSEA style plot to visualize our enrichment in a pathway of interest using the **plotEnrichment()** function.
We simply provide the pathway to plot and the ranking we used in test.

```{r, plotEnrichment, fig.height=4, fig.width=6}
plotEnrichment(mouse_Hallmarks[["HALLMARK_INTERFERON_GAMMA_RESPONSE"]],
               Act_minus_Rest_gsea)
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# ClusterProfiler for all things GSA

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# ClusterProfiler for all things GSA

---
"    
  )
  
}
```


## ClusterProfiler

clusterProfiler provides multiple enrichment functions that allow for comparison of your gene list to known (e.g. GO, KEGG) or custom gene sets. Detailed information about all of the functionality within this package is available [here](http://yulab-smu.top/clusterProfiler-book/).


It can perform both GSA and GSEA approaches, so is a nice one stop shop for everything. It is exemplified in the [ChIPseq course](https://rockefelleruniversity.github.io/RU_ChIPseq/presentations/singlepage/ChIPseq_In_Bioconductor3.html#Gene_ontology_and_gene_set_testing)

```{r, warning=F, message=F}
library(clusterProfiler)
```


---
## ClusterProfiler a brief demo

First we need a geneset. Lets look at Msigdb enrichment of C7 (immunological signature). Clusterprofiler needs a 2 column dataframe with the geneset names and gene IDs. 

```{r}

mm_c7 <- msigdbr(species = "Mus musculus", category = "C7")[,c("gs_name","entrez_gene")]

```

---
## ClusterProfiler a brief demo

Next we need our gene information. For a simple functional enrichment there is the *enricher* function. You just provide this a vector of gene IDs you want to check and the TERM2GENE data frame.
```{r, wanring=F, message=F}

sig_genes <- Activated_minus_Resting[Activated_minus_Resting$padj<0.05,1]

sig_gene_enr <- enricher(na.omit(sig_genes), TERM2GENE=mm_c7 )

```

The *GSEA* function requires similar inputs, but instead of a vector of gene IDS, it is a vector of ranking scores i.e. stat values. This vector is named with the geneIDs. 

---
## enrichResult object

The result is special object which contains your result. When you look at what is inside you get a preview of what test was done and what the results look like. You can also convert this to a dataframe and export.

```{r}
sig_gene_enr

```

---
## Visualizing the result

There are a couple of easy functions to visualize the top hits in your result. For example this dotplot which shows amount of overlap with geneset. These are also all built in ggplot2, so it is easy to modify parameters. For more info on ggplot2 check our course [here](https://rockefelleruniversity.github.io/Plotting_In_R/presentations/singlepage/ggplot2.html).

```{r, fig.width=10, fig.height=4}
library(ggplot2)
clusterProfiler::dotplot(sig_gene_enr, showCategory = 5) + theme( axis.text.y = element_text(size = 7))

```

<!-- --- -->
<!-- ## Visualizing the result -->

<!-- *emapplot* allows you to see how significant genesets relate to one another, by building a map based on how many genes overlap between groups. You can control how many groups are shown with the *showCategory* argument to customize your map. -->

<!-- ```{r} -->
<!-- emapplot(sig_gene_enr, showCategory = 30)   -->
<!-- ``` -->

---
## Time for an exercise


[Link_to_exercises](../../exercises/exercises/RNAseq_part3_exercise.html)

[Link_to_answers](../../exercises/answers/RNAseq_part3_answers.html)

